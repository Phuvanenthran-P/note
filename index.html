<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pinned Notes PWA</title>
  <link rel="manifest" href="/manifest.json">
  <style>
    /* Minimal Tailwind-like quick styles (so no external deps) */
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#9aa4b2;--text:#e6eef6}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071028 0%,#071032 100%);font-family:Inter,system-ui,Segoe UI,Arial;color:var(--text)}
    .app{max-width:900px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:20px}
    .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;box-shadow:0 6px 16px rgba(2,6,23,0.6)}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:16px;margin-top:16px}
    textarea{width:100%;min-height:220px;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);resize:vertical}
    input[type=text]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    button{border:0;padding:10px 12px;border-radius:10px;background:var(--accent);color:#012;cursor:pointer}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
    ul.note-list{list-style:none;padding:0;margin:0;max-height:520px;overflow:auto}
    li.note{padding:10px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
    .meta{font-size:12px;color:var(--muted)}
    .note-actions{display:flex;gap:8px;align-items:center}
    footer{margin-top:18px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="card" style="flex:1;display:flex;align-items:center;gap:12px;padding:10px">
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40'><rect width='100%' height='100%' rx='8' fill='%2306b6d4'/></svg>" width="44" height="44" alt="logo">
        <div>
          <h1>Pinned Notes PWA</h1>
          <div class="meta">Write notes. Save. Pin — stays as a notification until you delete it here.</div>
        </div>
        <div style="margin-left:auto">
          <button id="installBtn" class="btn-ghost">Install app</button>
        </div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <label><input id="noteTitle" type="text" placeholder="Title (optional)"></label>
        <textarea id="noteBody" placeholder="Write your note here..."></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="saveBtn">Save</button>
          <button id="savePinBtn" class="btn-ghost">Save + Pin</button>
          <button id="clearBtn" class="btn-ghost">Clear</button>
        </div>
      </section>

      <aside class="card">
        <h3 style="margin-top:0">Saved notes</h3>
        <ul class="note-list" id="notes"></ul>
        <footer>Notes are stored locally. Pinned notifications use the Notification API + Service Worker.</footer>
      </aside>
    </div>
  </div>

<script>
// --- small IndexedDB helper (promisified) ---
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open('pinned-notes-db',1);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains('notes')){
        const s = db.createObjectStore('notes',{keyPath:'id'});
        s.createIndex('pinned','pinned',{unique:false});
      }
    }
    req.onsuccess = ()=>resolve(req.result);
    req.onerror = ()=>reject(req.error);
  })
}
async function putNote(note){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction('notes','readwrite');
    const store = tx.objectStore('notes');
    store.put(note);
    tx.oncomplete = ()=>resolve(note);
    tx.onerror = ()=>reject(tx.error);
  })
}
async function getAllNotes(){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction('notes','readonly');
    const store = tx.objectStore('notes');
    const req = store.getAll();
    req.onsuccess = ()=>resolve(req.result);
    req.onerror = ()=>reject(req.error);
  })
}
async function delNote(id){
  const db = await openDB();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction('notes','readwrite');
    tx.objectStore('notes').delete(id);
    tx.oncomplete = ()=>resolve();
    tx.onerror = ()=>reject(tx.error);
  })
}

// --- UI and logic ---
const noteTitle = document.getElementById('noteTitle');
const noteBody = document.getElementById('noteBody');
const saveBtn = document.getElementById('saveBtn');
const savePinBtn = document.getElementById('savePinBtn');
const clearBtn = document.getElementById('clearBtn');
const notesList = document.getElementById('notes');
const installBtn = document.getElementById('installBtn');

let deferredPrompt = null;
window.addEventListener('beforeinstallprompt', (e)=>{
  e.preventDefault();
  deferredPrompt = e;
  installBtn.style.display = 'inline-block';
});
installBtn.addEventListener('click', async ()=>{
  if(!deferredPrompt) return;
  deferredPrompt.prompt();
  const choice = await deferredPrompt.userChoice;
  deferredPrompt = null;
  installBtn.style.display = 'none';
});

async function refreshNotes(){
  const arr = await getAllNotes();
  arr.sort((a,b)=> (b.id-a.id));
  notesList.innerHTML='';
  for(const n of arr){
    const li = document.createElement('li');
    li.className='note';
    li.innerHTML = `<div><strong>${escapeHtml(n.title||'Untitled')}</strong><div class="meta">${escapeHtml(n.body.slice(0,120))}</div></div>`;
    const actions = document.createElement('div');
    actions.className='note-actions';
    const pinBtn = document.createElement('button'); pinBtn.className='btn-ghost'; pinBtn.textContent = n.pinned? 'Unpin' : 'Pin';
    pinBtn.addEventListener('click', ()=> togglePin(n));
    const openBtn = document.createElement('button'); openBtn.className='btn-ghost'; openBtn.textContent='Open';
    openBtn.addEventListener('click', ()=>{
      noteTitle.value = n.title; noteBody.value = n.body;
    });
    const del = document.createElement('button'); del.className='btn-ghost'; del.textContent='Delete';
    del.addEventListener('click', async ()=>{
      if(n.pinned) await unpinNotification(n);
      await delNote(n.id);
      await refreshNotes();
    });
    actions.appendChild(pinBtn); actions.appendChild(openBtn); actions.appendChild(del);
    li.appendChild(actions);
    notesList.appendChild(li);
  }
}

function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}

function makeId(){return Date.now() + Math.floor(Math.random()*1000)}

saveBtn.addEventListener('click', async ()=>{
  const note = {id: makeId(), title: noteTitle.value.trim(), body: noteBody.value, pinned:false};
  await putNote(note); await refreshNotes();
  noteTitle.value=''; noteBody.value='';
});
savePinBtn.addEventListener('click', async ()=>{
  const note = {id: makeId(), title: noteTitle.value.trim(), body: noteBody.value, pinned:true};
  await putNote(note);
  await sendPinRequestToSW(note);
  await refreshNotes();
  noteTitle.value=''; noteBody.value='';
});
clearBtn.addEventListener('click', ()=>{ noteTitle.value=''; noteBody.value=''; });

async function togglePin(n){
  n.pinned = !n.pinned;
  await putNote(n);
  if(n.pinned) await sendPinRequestToSW(n);
  else await unpinNotification(n);
  await refreshNotes();
}

async function sendPinRequestToSW(note){
  if('serviceWorker' in navigator && navigator.serviceWorker.controller){
    navigator.serviceWorker.controller.postMessage({type:'PIN_NOTE',note});
  } else {
    // If no service worker controller yet, register and then send — but we'll also show notification from page as fallback
    try{ const reg = await navigator.serviceWorker.getRegistration();
      if(reg && reg.showNotification){
        reg.showNotification(note.title||'Pinned note', {body: note.body, tag: 'pinned-note-'+note.id, requireInteraction: true, data:{id:note.id}});
      } else {
        // fallback: Notification from page
        if(Notification.permission==='granted'){
          new Notification(note.title||'Pinned note',{body:note.body,tag:'pinned-note-'+note.id,requireInteraction:true,data:{id:note.id}});
        }
      }
    }catch(e){console.warn(e)}
  }
}

async function unpinNotification(note){
  // Ask service worker to close notifications with this tag and clear pinned flag
  if('serviceWorker' in navigator && navigator.serviceWorker.controller){
    navigator.serviceWorker.controller.postMessage({type:'UNPIN_NOTE',id:note.id});
  }
  // Also attempt to close notifications from page
  if('getNotifications' in ServiceWorkerRegistration.prototype){
    const regs = await navigator.serviceWorker.getRegistration();
    if(regs){
      const notifs = await regs.getNotifications({tag:'pinned-note-'+note.id});
      notifs.forEach(n=>n.close());
    }
  }
  // update storage
  note.pinned = false;
  await putNote(note);
}

// --- request permission and register SW ---
async function init(){
  if('serviceWorker' in navigator){
    try{
      const reg = await navigator.serviceWorker.register('/sw.js');
      console.log('sw registered',reg);
    }catch(e){console.warn('sw reg failed',e)}
  }
  if('Notification' in window){
    if(Notification.permission === 'default'){
      try{ await Notification.requestPermission(); }catch(e){}
    }
  }
  await refreshNotes();
  // try to show pinned notes (in case service worker didn't on its own)
  const all = await getAllNotes();
  for(const n of all){ if(n.pinned) sendPinRequestToSW(n); }
}
init();

// Listen for messages from SW (e.g. when notification clicked or removed)
navigator.serviceWorker && navigator.serviceWorker.addEventListener('message', async (ev)=>{
  const data = ev.data || {};
  if(data.type === 'NOTIF_CLICK'){ /* could open UI or focus */ }
  if(data.type === 'NOTIF_CLOSED'){ /* could sync state */ }
  // refresh notes in case pin state changed
  await refreshNotes();
});

</script>
</body>
</html>
